{
  "title": "Chapter 5: Using Data Structures",
  "modules": [
    {
      "module_title": "Overview",
      "content": "Having structured data is only useful if we also have a structred way to use the information. Manually manipulating the data is very time consuming and difficult which is the opposite of the essance of programming. In this chapter we will go over better ways to manipulate data. We have seen a couple examples in the previous chapter, but we will go over them more in this chapter."
    },
    {
      "module_title": "Using Lists",
      "content": "***Simple loop:***<br>The most fundemental way, in Python, to itterate over a ```List``` is to use the ```in``` operator. Python being Python it is very straight forward and english like to do this. We simply create the loop in this structure: ```for x in y```. The common naming convention for this would be to have your ```List``` (y) to be plural and the temporary variable (x) to be the singular version. Below is an example:\n```python\n# Looping over a list of numbers\nnumbers = [2, 5, 1, 7]\n\nfor number in numbers:\n    print(number)\n\n# If we have a list of list's we can also itterate over those\nlists = [[1, 2], [3, 4]]\n\nfor list in lists:\n    print(list)\n```\n```number and list``` is the singular version of ```numbers and lists```.<br><br>***Loop by index:***<br>Lets say we want to multiply every number in our list by 5. We modify the loop to multiply every number by 5 right?\n```python\n# Trying to multipy numbers by 5\nnumbers = [2, 5, 1, 7]\n\nfor number in numbers:\n    number * 5\n\nprint(numbers)\n```\nWhy doesn't it work?<br><br>When we use a temporary variable to itterate over a ```List```, for normal data types Python creates this variable as a copy of the item. However, for mutable data types like ```List```'s ```Dictionaries```, etc. Python creates a reference to the item so we can use the previous method to change the item. Below shows how the previous method can be used to change a nested ```List```:\n```python\n# Appending 5 to each list\nlists = [[1, 2], [3, 4]]\n\nfor list in lists:\n    list.append(5)\n\nprint(lists)\n```\nThis will work because list is a reference to each ```List``` instead of a copy.<br><br>To itterate over normal data types and change each item we need to take advantage of the fact that ```List```'s are ordered by index. We can recall that ```List```'s start at the 0th index and we can use the ```[]``` to access an item by index. There are 2 ways we can loop over a ```List``` by index: ```range(len())``` and ```enumerate()```.<br><br>```range(len())```:\n```python\n# We are going to shorten index to i\nnumbers = [2, 5, 1, 7]\n\nfor i in range(len(numbers)):\n    numbers[i] *= 5\n\nprint(numbers)\n```\nRemeber from the ```loops``` chapter ```range()``` creates a sequence from 0 to the number you pass in, the ```len()``` function returns the length of the list. (The length would be 4 but since range doesn't include the number you pass in the number generated is 0-3).<br><br>```enumerate():```\n```python\n# We are going to shorten index to i\nnumbers = [2, 5, 1, 7]\n\nfor i, _ in enumerate(numbers):\n    numbers[i] *= 5\n\nprint(numbers)\n```\nThe ```enumerate()``` function is different than the ```range()``` function because it returns 2 values. Essentially ```range()``` only returns the index, ```enumerate()``` returns the index (```i```) and a copy/reference (just like the simple for loop) which we named ```_```. We can extract these 2 values by creating variables for them, this is called ****unpacking**** which we will go over in later chapters. Since we don't actually need the copy of the unpacked copy we named it ```_```. In Python the normal naming convention for variables you unpack but don't use is ```_```.<br><br>Usually ```range(len())``` is used for strictly manipulating by index, ```enumerate()``` is a cleaner way to get the index but is common used if you need the index and the item at the same time.<br><br>***List Comprehension:***<br>Instead of directly changing our ```List``` sometimes we want to create a different ```List``` with the data. The thought process behind this would be to create a new ```List```, itterate over the original ```List```, add the apporpriate data to the new ```List```. ****Try to implement this.****<br>This is a common straight-forward way to implement this:\n```python\n# This is correct\nold = [1, 2, 3]\nnew = []\n\nfor i in range(len(old)):\n    new.append(numbers[i] * 5)\n\nprint(old)\nprint(new)\n```\nWhile this works the more Pythonic and cleaner way to write this would to be with list comprehensions.<br><br>List comprehensions allow us to create ```Lists``` in one line to make your code easier to read. The syntax goes as follows ```new_list = [x for x in itterable if condition]```. We can read this as ```x``` being the item we are placing in the new list. The for loop is the normal syntax we go over the itterable with ```x```. We only place the current ```x``` in the new list if it meets the condition.\n```python\n# Only adding even numbers to new list\nnumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\n# n short for number\nevens = [n for n in numbers if n % 2 == 0]\n\nprint(evens)\n```\nWe can also use multiple variables to unpack items.\n```python\n# Unpacking tuple pairs\npairs = [(1, 'a'), (2, 'b'), (3, 'c')]\n\n# Unpacked\nresult = [f\"{num}:{char}\" for num, char in pairs]\nprint(result)\n```\nWe can also use the ```zip()``` function to create pairs with 2 or more ```Lists```.\n```python\n# Combine 3 lists\nnames = [\"Bob\", \"Jerry\", \"Larry\"]\nages = [40, 29, 67]\nhobbies = [\"Tennis\", \"Golf\", \"Fishing\"]\n\nresult = [x for x in zip(names, ages, hobbies)]\nprint(result)\n```\n**Zip** is a useful function that has many uses we will go over it in more detail later.<br><br>***Sorting:***<br>The last operation we will go over for ```List```'s is sorting. Your data may be organized in a way where it is easily accessible, however we may need more organization. We have 2 functions in Python that will sort our ```List```'s: ```sorted()``` and ```list.sort()```. The main difference in both of these is that ```sorted()``` returns a new list and ```list.sort()``` sorts the existing list (list is refering to the list you want to sort).<br><br>```list.sort():```\n```python\n# 2 optional parameters list.sort(inverse, key)\nums = [5, 7, 1, 10, 871, 20]\nnums.sort(inverse=True)\nprint(nums)\n```\nBy default ```list.sort()``` sorts in ascending order. The 2 optional parameters are ```inverse``` which can either be ```True``` or ```False```, and ```key``` which can be a function that sorts by a specific criteria.<br><br>```sorted():```\n```python\n# 1 required parameter and 2 optional sorted(itterable, key, reverse)\nnums = [5, 7, 1, 10, 871, 20]\nsort_nums = sorted(nums)\nprint(sort_nums)\n```\nThe 2 optional parameters are the same as ```list.sort()``` however, since this returns a new list we must pass the list which we want to sort."
    },
    {
      "module_title": "Using Dictionaries",
      "content": "***Accessing Dictionary:***<br>We access values by the key. The syntax is similar to accessing ```List```'s by index using ```[]```. If the key doesn't exist we will get an error if we try to access it. We check if a key is valid using the ```in``` operator. We can create new keys by simply accessing the ```Dictionary``` by the new key and giving it a value. Lastly, we can remove pairs using either ```del``` or ```.pop()```.\n```python\n# Basic Operations on dictionaries\nmy_dict = {'a': 1, 'b': 2, 'c': 3}\n\n# Accessing\nprint(my_dict['a'])\n\n# Adding new pair\nmy_dict['d'] = 5\n\n# Removing a pair\ndel my_dict['b']\n\nprint(my_dict)\n```\nThese are some of the basic operations you can do wit ```Dictionaries```.<br><br>***Built in Functions:***<br>```Dictionaries``` have a couple of built-in functions that allow you to access elements. These include ```.items()```, ```.get()```, and ```.values()```.<br><br>```.items()```<br>This function returns an object of ```Tuples``` where each tuple is every key:value pair. We use this function to itterate over ```Dictionaries```, check whether a key:value pair is present in, and to create tuples out of key:value pairs.\n```python\n# What .items() returns\nmy_dict = {\"Jerry\": 0, \"Larry\": 20, \"Bob\": 90}\nprint(my_dict.items())\n\n# Itterating over dictionary\nfor key, value in my_dict.items():\n    print(f\"Name: {key}, Value: {value}\")\n\n# Check for key:value pair\nkey = \"Bob\"\nvalue = 90\nif (key, value) in my_dict.items():\n    print(\"Valid Pair\")\n```\nWe use unpacking to get the pairs from the tuples that are returned.<br><br>```.get()```<br>This function allows you to access values from a specified key. You may be thinking this is the same as accessing by ```[]```. While it does achieve the same outcome, ```.get()``` is a safer option because of it's parameters. It takes 2 parameters, the ```key``` (required) and a ```default value``` (optional). If the key doesn't exist in the default value will be returned.\n```python\nmy_dict = {\"Jerry\": 0, \"Larry\": 20, \"Bob\": 90}\nkey = \"Tom\"\n\n# Unsafe using []\nprint(my_dict[key])\n\n# Safe using .get()\nprint(my_dict.get(key, \"Invalid Key\"))\n```\nHaving safe code is good practice, using ```.get()``` rather than ```[]``` will cause less problems.<br><br>```.values()```<br>This function simply returns all of the values as a ```List``` object. The use cases for this is to check if a value exists without using keys and to create a list of values.\n```python\n# Values object\nmy_dict = {\"Jerry\": 0, \"Larry\": 20, \"Bob\": 90}\nprint(my_dict.values())\n\n# Checking values\nvalue = 90\nif value in my_dict.values():\n    print(f\"{value} is valid\")\n\n# Usage with list\nvalues = list(my_dict.values())\nfor value in values:\n    print(value)\n```\n<br>****Note:****<br>These methods return ***objects*** we will go over these in a later chapter. Just know, if we want to treat them as a desired data structure we must first convert them to the desired data strcuture.<br><br>***Dictionary Comprehension:***<br>Just like ```List```'s we can create new ```Dictionaries``` on one line using comprehension. 2 common uses of ```Dictionary comprehension``` is to create new ```Dictionaries``` and filter old ones.\n```python\n# Creating a dictionary of squares\nsquares = {x: x**2 for x in range(1, 5)}\nprint(squares)\n\n# Filtering\nx = 19\nmy_dict = {\"Jerry\": 0, \"Larry\": 20, \"Bob\": 90}\nover_x = {name: val for name, val in my_dict.items() if val > x}\nprint(over_x)\n```\nFor the filtering example notice how we loop over the ```.items()``` object and use an ```if``` statement on the same line to filter the val's."
    },
    {
      "module_title": "Using Sets and Tuples",
      "content": "```Sets``` and ```Tuples``` are more straight forward with their common use-cases. ```Sets``` are used to remove duplicates from ```Lists``` and are used to compare 2 data structures and find relations. ```Tuples``` are mainly used to contain multiple pieces of data as one, preferred over ```Lists``` because of their immutability and speed.<br><br>```Sets```\n```python\n# Removing duplicates\nbefore = [1, 2, 3, 4, 4, 5, 2, 5]\nafter = set(before)\nprint(after)\n\n# Finding relationships\nsecond = {6, 4, 5 , 2, 1, 8}\n\n# Union of 2 sets\nprint(after | second}\n\n# Find common elements\nprint(after & second)\n\n# Find if specific element is in set\nx = 5\nprint(x in second)\n```\n<br>```Tuples```\nTuples are used a lot when returning multiple values in user defined functions. We will go over those in a later chapter. I will not go over that now, I will just give simple usage. Also, the immutability characteristic of ```Tuples``` allows for secure data.\n```python\n# Using tuples to create immutable items\nnumbers = ((\"pi\", 3.14), (\"e\", 2.71))\nnumber[0] = (\"pi\", 5)\nprint(numbers)\n```\nThe main take-away is that using ```Tuples``` will protect data."
    }
  ],
  "exercise": "",
  "answer": ""
}
