{
  "title": "Chapter 4: Data Structures",
  "modules": [
    {
      "module_title": "Overview",
      "content": "In this chapter we go over the basic data structures Python has to offer. ```Data Structures``` are tools we can use to store multiple variables. Having to manually keep track of individual variables can get confusing. Data structures allow us to have a organized structure to data. The 3 data structures we will go over in this chapter are ```Lists```, ```Sets```, and ```Dictionaries```."
    },
    {
      "module_title": "Lists",
      "content": "The simplest data structure in Python is the ```List```. A ```List``` is just a ordered collection of items. They are similar to array's in other languages, however they do not have a fixed size and they can contain many different data types. We create lists using ```[]```. Initializing and decalring data structures is similar to variables. Below is an example of a list.\n```python\n# List in Python\nlist = [5, \"Hi\", 3.14]\n```\nNotice how we can store different data types such as an ```int```, ```string```, and ```double``` in the same list.<br><br>When populating the ```List``` we seperate values with ```,```. As stated earlier, ```List```'s are ordered, meaning each item has unique indicies. Reading from left to right the indcies start from ```0``` and end at ```(amount of items in list) -1 ```. We can access items in the ```List``` using ```[]``` and their correspoding index. Python is a 0 indexing language, meaning everything starts at 0 instead of 1.\n```python\n# Accessing items from list of fruits\nfruits = [\"Apple\", \"Orange\", \"Pear\"]\nprint(fruits[0])\n```\nRun this in the editor to see the output. When accessing items from a list I like reading it as: \"List name\" ```at``` \"Index\".<br><br>We can also change the contents of ```List```'s using it's indicies and the assignment operator ```=```.\n```python\n# Changing Apple to Pizza\nfruits = [\"Apple\", \"Orange\", \"Pear\"]\nfruits[0] = \"Pizza\"\nprint(fruits[0])\n```\nBe careful accessing items using indices. If you try to access an item outside of the index range you will get an error. What is the index range of the fruits list? Try accessing an item outside of the range.<br><br>```List```'s also have built in functions that perform common tasks. Common ones are:<br>-```append()``` (adds a value to the end of the list)<br>-```count()``` (returns the amount of values in the list)<br>-```sort()``` (sorts the list in ascending order)<br>There are many other built in functions for ```List```, we will go over them as we use them, they can also be found here: https://www.w3schools.com/python/python_lists.asp.<br><br>**Note**: Every data structure we go over has their own set of built in functions."
    },
    {
      "module_title": "Tuples",
      "content": "The second data type we have is the ```Tuple```. These are very similar to ```List```'s. They both are ordered, and can hold different types of data. The main difference is that ```tuples cannot be changed``` after they have been created and ```we use () instead of []```. Not being able to change the content of a ```Tuple``` after it has been created, usually refered to as being ```immutable```, they have a fixed size and order.\n```python\n# Tuple example\ntuple = (1, \"Hi\", 3.14)\n```\nVery similar to ```List```.<br><br>If we try to change an element we will get an error. Try running this code:\n```python\n# Changing an item in a tuple\npoints = (54, 18, 36)\npoints[0] = 10\n```\nNotice the error.<br><br>```Tuple```'s may seem pointless if they have less functionality that ```List```'s, however they are much faster than ```List```'s when retrieving data and require less memory to create because of the lack of overhead."
    },
    {
      "module_title": "Sets",
      "content": "A common way we like to organize data is to remove duplicates. We could manually compare each element in a ```List``` and remove duplicates, or we can use a ```Set```. The key points of ```Sets```'s are that they only contain unique values, they are mutable (it can be changed after being created), and they are unordered. Unlike the previous 2 data structures, ```Set```'s are ```unordered```, meaning internally the items of a ```Set``` are not structured by index. To create a ```Set``` we use ```{}```. Below is an example:\n```python\n# Example of a set\nmy_set ={1, 2, 3}\n```\nPrint out the set in the code editor<br><br>Like stated earlier ```Set```'s aren't ordered. We cannot access elements of ```Set```'s using thier index. Try running this code:\n```python\nmy_set = {1, 2, 3}\nprint(my_set[0])\n```\nNotice the error. While we can't change the elements individually we can add and remove items using the built in ```Set``` functions:\n```python\nmy_set = {1, 2, 3}\n\n# Add item\nmy_set.add(5)\n\n# Remove item\nmy_set.remove(2)\n\nprint(my_set)\n```\nA common way we check if a specific item is in the ```Set``` is to use the ```in``` operator. ```in``` is the membership operator, like with ```loop```'s we can use in to check whether an item is in a ```sequence```, ```string```, or a ```collection``` like the ones mentioned in this chapter. Below is an example of checking if an item is ```in``` a ```Set```:\n```python\n# Usage of in with sets\nmy_set = {1, 2, 3}\nprint(2 in my_set)\nprint(8 in my_set)\n```\nNotice the output, if the item is ```in``` the ```Set``` it prints ```True```, otherwise ```False```. The ```in``` operator returns a boolean value.<br><br>A common way we use ```Set```'s is to remove duplcates from a ```List```. For every built in collection in Python we can turn one into another. Meaning we can turn a ```List``` into a ```Set``` essentially removing duplicates from the ```List```.\n```python\n# List to Set\nmy_list = [1, 2, 3, 3]\nlist_2_set = set(my_list)\nprint(list_2_set)\n```\nConverting a collection into another is a simple process. We just use the built in function corresponding to the collection we want to create and pass the previous collection into it. For this example we used the ```set()``` and passed a list. Other conversions are similar."
    },
    {
      "module_title": "Dictionaries",
      "content": "The final data structure we will go over is the ```Dictionary```. They are unique to other data structures because they contain **key:value pairs**. A key:value pair is, like the naming implies, a pair of values; one being a key and the other being the value. We can think of ```Dictionaries``` as a warehouse, the key is a specific shelf in the warehouse, and the value is the content of that specific shelf. We use the ```{}``` to declare a ```Dictionary``` (the same ```{}``` with ```Set```'s), and each pair follows the schema of ```key:value```. Below is an example:\n```python\n# Dictionary that contains ages\nages = {\"Bob\": 50, \"Jerry\": 39, \"Larry\": 12}\n```\nSyntax is very similar to ```Set```'s.<br><br>The reason why ```Dictonaries``` are commonly used is the fast lookups for elements. Instead of using index to get a value we use the key like so:\n```python\n# Using the same example from above\nprint(ages[\"Bob\"]\n```\nWe can get exactly what we want instead of figuring out which index an item is at.<br><br>to maintain the ability to look up items the keys and values have their own characteristics.<br><br>```Keys```<br>-Every key must be unique<br>-Keys must be immutable (the type that you use for keys cannot be mutable)<br>-Keys can be of different types (sometimes lead to unwanted results)\n```python\n# Example of working keys\nworking = {1: \"Bob\", 1.0: \"Jerry\", \"1\": \"Terry\"}\nprint(working)\n\n# Example of bad keys\nbad = {[1, 2]: \"Bob\"}\nprint(bad)\n\n# Example of good keys\ngood = {\"Bob\": 50, \"Jerry\": 39, \"Larry\": 12}\nprint(good)\n```\nThe working example works but gives unexpected output, the bad example doesn't work because ```List```'s are mutable, the good one contains all unique keys to avoid confusion.<br><br>```Values```<br>-Values are very flexible and don't have many constraints like ```Keys```<br>-They allow for any data type<br>-They can contain duplicates<br>-They are allowed to be mutable\n```python\n# Flexibility of values allow dictionaries to be powerful\nmy_dict = {\n    \"int\": 1, \n    \"str\": \n    \"Hi\", \n    \"list\": [1, 2, 3], \n    \"set\": {1, 2, 3}, \n    \"nested\": {\"key\": \"value\"}\n}\n```\n```Values``` can have any data type or data structure, nesting ```Lists, Sets, Dictionares``` inside of values is common."
    }
  ],
  "exercise": "",
  "answer": ""
}
