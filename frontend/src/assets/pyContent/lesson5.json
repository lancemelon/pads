{
  "title": "Chapter 6: Functions",
  "modules": [
    {
      "module_title": "Overview",
      "content": "Up until now we have been leveraging built-in functions. We have been treating them as black-boxes that can achieve certian tasks. In this chapter we will go over what these functions are, why we should use functions and how to create our own functions. We pretty much have all of the basic building blocks to create complex programs in Python."
    },
    {
      "module_title": "What are Functions. Why?",
      "content": "Functions are specific blocks of code that perform specific tasks. When writing complex programs we often repeat code in different parts of our program, your code can get messy if you have repeated complex logic. Having a pre-defined function you can call through out your program helps with readability and structure.<br><br>The structure of a function can be broken down into the ```definition```, ```parameters```, ```logic```, and ```return data```. When defining a function the naming is important, having a descriptive name allows the function to be used correctly through out your code. Parameters are pieces of data we pass into the function. Being able to pass custom data into functions allow the output to be more useful in many situations. The encapsulation of the logic in your function is important, so make sure you add as much logic related to your function. Finally, the returned data makes your functions more useful outside of the logic.<br><br>The only reqired components of a function is the definition and the logic, having parameters and returned data makes functions useful in different scenarios.<br><br>Functions may seem pointless because in reality re-writing logic when necessary is essentially the same as writing functions that can be called through-out. But, imagine if we had to write the ```range(len())``` logic every time we wrote a loop. The repetition can get out of hand and unreadable. Now imagine we wanted to change the logic a bit for that function, we would have to re-write the logic every where we used it. Having functions cleans up our code, makes maintaince easier, and makes our lives as developers less of a pain."
    },
    {
      "module_title": "Creating our own.",
      "content": "To define a function in Python we use the ```def``` keyword followed by whatever we want to name it. The rest of the definition is the same as any other code block assigned to a header, we use the ```:``` then indent all of the code inside of the header. After defining a function we can call it with its name followed by ```()```\n```python\n# Our first function\ndef my_func:\n    print(\"This is a function\")\n\nmy_func()\n```\nWe defined ```my_func``` and we called it using the ```()```.<br><br>***Parameters:***<br>For special cases we may need to pass information from our program to our function to produce a explicit output. In these cases we use ```parameters```. We create parameters by simply defining a variable inside of the ```()``` in our function definition.\n```python\n# Function with parameters\ndef my_func1(name):\n    print(\"Hello \", name)\n\nmy_func2(name, greeting):\n    print(f\"{greeting} {name}\")\n\nmy_func1(\"Bob\")\nmy_func2(\"Bob\", \"Hi\")\n```\nDefined 2 functions to show an example of a single parameter and multiple parameters.<br><br>***Default Parameters:***<br>Once a parameter is defined in the function definition, by default every parameter is required whenever the function is called. If we want to have optional parameters we can define default values to our parameters. A default value is set by using the ```=``` operator whenever we define the parameter in the definition.\n```python\n# Previous my_func2 with default parameter\ndef my_func2(name, greeting=\"Hello\"):\n    print(f\"{greeting} {name}\")\n\nprint(\"Bob\")\nprint(\"Larr\", \"Explicit Greeting\")\n```\nWe called the same function using the default parameter and an explict parameter.<br><br>***Return:***<br>Returning data back to our program from our function gives is fundemental. In most cases our functions cannot interact with the environment outside of it's scope so passing in information and returning new information is crucial to well performing code. To return data we simply use the ```return``` keyword. To return data we follow the ```return``` keyword with the variable that we want to return.<br><br>We are limited to only returning one object back to our program. However, as you may have noticed from other chapters we can leverage data structures to return multiple pieces of data. The common way to return multiple pieces of data is to use the ```tuple```, because of it's speed and immuatability.<br><br>Even though we can only return 1 object we can still use multiple return statements. After a return statement is read the function automatically exits, even if you have code after it won't be run. Multiple return statements are usually used with conditionals to exit the function with the relevant data for the condition.<br><br>Below is how return statements are typically used:\n```python\n# Adding 2 numbers\ndef add_num(x, y):\n    return x + y\n\n# Multi-purpose function\ndef circle_info(radius):\n    cir = 2 * 3.14 * radius\n    area = 3.14 * radius ** 2\n    return (cir, area)\n\n# Multiple returns for conditions\ndef greet(name):\n    if name == \"Bob\":\n        return f\"Hello {name}!\"\n    else:\n        return \"You're not Bob!\"\n\nprint(add_num(1000, 5))\n\n# We can use index or unpacking to get contents of tuple\ncircum, area = circle_info(5)\nprint(f\"Circumeference is {circum}, area is {area}\")\n\nprint(greet(\"Bob\")\nprint(greet(\"Larry\")\n```\n"
    },
    {
      "module_title": "Example",
      "content": "Functions are essential to maintaining and orgranizing our code. Being able to call a function any where in our program enables us to not worry about losing track of our progress. In the next chapter we will go over libraries which are pretty much pre-written functions you can use to solve tasks. Python has a lot of pre-written functions and we have been using many. Below is a little example of how the ```zip()``` function in Python would be written if yuo wanted to make it from scratch.\n```python\n# Zip joins itterables togeather to make pairs by index\ndef zip_from_scratch(a, b):\n    length = min(len(a), len(b))\n    result = []\n    for i in range(length):\n        result.append((a[i], b[i]))\n    return result\n\na = [1, 2, 3]\nb = [4, 5, 6]\nnew = zip_from_scratch(a, b)\nprint(new)\n```\nOf course this doesn't have all of the properties of the Python ```zip()``` function. This is just to show the praticallity of functions. Imagine having to write this (plus more) to run the ```zip()``` function every time you need it."
    }
  ],
  "exercise": "",
  "answer": ""
}
